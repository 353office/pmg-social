require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { createDB } = require('./db');
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const fs = require('fs');
const path = require('path');
const { migrateSqliteToPostgres } = require('./scripts/sqliteMigrator');

const app = express();
app.get("/", (req, res) => res.status(200).send("OK"));
app.get("/health", (req, res) => res.status(200).json({ ok: true }));

const PORT = process.env.PORT || 3000;
app.listen(PORT, "0.0.0.0", () => {
  console.log(`
listening on ${PORT}

Server: http://localhost:${PORT}
API:    http://localhost:${PORT}/api

Example logins:  student_11Ð°_1 / student123
        teacher_11Ð° / teacher123
        admin / admin123
`);
    });
    
app.use(cors({
  origin: (origin, cb) => {
    const allowed = (process.env.CORS_ORIGIN || '').split(',').map(s => s.trim()).filter(Boolean);
    if (!origin) return cb(null, true); // server-to-server / curl
    if (allowed.length === 0) return cb(null, true); // default allow all (dev)
    return cb(null, allowed.includes(origin));
  },
  credentials: true,
}));
app.use(express.json());

// Initialize database (PostgreSQL via DATABASE_URL)
const db = createDB();

async function initDB() {
  // NOTE: UUIDs are generated by the application (uuidv4).
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id UUID PRIMARY KEY,
      username TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      email TEXT UNIQUE,
      full_name TEXT NOT NULL,
      role TEXT NOT NULL,
      class_grade TEXT,
      class_letter TEXT,
      bio TEXT,
      profile_picture TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS sessions (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token UUID UNIQUE NOT NULL,
      expires_at TIMESTAMPTZ NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS posts (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      image_url TEXT,
      visibility TEXT NOT NULL DEFAULT 'public',
      engagement_score INTEGER NOT NULL DEFAULT 0,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS likes (
      id UUID PRIMARY KEY,
      post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(post_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS comments (
      id UUID PRIMARY KEY,
      post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS calendar_events (
      id UUID PRIMARY KEY,
      title TEXT NOT NULL,
      description TEXT,
      location TEXT,
      event_date TEXT NOT NULL,
      event_time TEXT,
      event_type TEXT,
      class_grade TEXT,
      class_letter TEXT,
      created_by UUID NOT NULL REFERENCES users(id),
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS clubs (
      id UUID PRIMARY KEY,
      name TEXT NOT NULL,
      description TEXT,
      meeting_schedule TEXT,
      meeting_location TEXT,
      leader_id UUID NOT NULL REFERENCES users(id),
      status TEXT NOT NULL DEFAULT 'approved',
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS club_members (
      id UUID PRIMARY KEY,
      club_id UUID NOT NULL REFERENCES clubs(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      role TEXT NOT NULL DEFAULT 'member',
      joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(club_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS conversations (
      id UUID PRIMARY KEY,
      name TEXT,
      is_group BOOLEAN NOT NULL DEFAULT FALSE,
      created_by UUID REFERENCES users(id),
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS conversation_participants (
      id UUID PRIMARY KEY,
      conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(conversation_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS messages (
      id UUID PRIMARY KEY,
      conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
      sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      message_type TEXT NOT NULL DEFAULT 'text',
      attachment_url TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS notifications (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      type TEXT NOT NULL,
      title TEXT NOT NULL,
      message TEXT NOT NULL,
      related_id UUID,
      is_read BOOLEAN NOT NULL DEFAULT FALSE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS attachments (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      file_name TEXT NOT NULL,
      file_type TEXT NOT NULL,
      file_size INTEGER NOT NULL,
      file_url TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}


async function createNotification(userId, type, actorId, postId = null, commentId = null) {
  if (userId === actorId) return;
  try {
    const id = uuidv4();
    await db.prepare(`
      INSERT INTO notifications (id, user_id, type, actor_id, post_id, comment_id)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(id, userId, type, actorId, postId, commentId);
  } catch (error) {
    console.error('Notification error:', error);
  }
}

function parseMentions(content) {
  if (!content) return [];
  const mentionRegex = /@(\w+)/g;
  const mentions = [];
  let match;
  while ((match = mentionRegex.exec(content)) !== null) {
    mentions.push(match[1]);
  }
  return mentions;
}

async function seedData() {
  const count = await db.prepare('SELECT COUNT(*) as count FROM users').get();
  if (count.count > 0) {
    console.log('âœ“ Data already exists');
    return;
  }

  console.log('Creating sample data...');

  const hashPassword = (p) => bcrypt.hashSync(p, 12);

  // Create users
  const createUser = await db.prepare(`
    INSERT INTO users (id, username, password, full_name, role, class_grade, class_letter, bio)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  // Admin
  createUser.run(uuidv4(), 'admin', hashPassword('admin123'), 'Ð˜Ð²Ð°Ð½ Ð“ÐµÐ¾Ñ€Ð³Ð¸ÐµÐ²', 'admin', null, null, 'ÐÐ´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€');

  // Moderator
  createUser.run(uuidv4(), 'director', hashPassword('director123'), 'ÐœÐ°Ñ€Ð¸Ñ Ð”Ð¸Ð¼Ð¸Ñ‚Ñ€Ð¾Ð²Ð°', 'moderator', null, null, 'Ð”Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€');

  // Teachers
  const teachers = [];
  ['10', '11', '12'].forEach(grade => {
    ['Ð°', 'Ð±', 'Ð²'].forEach(letter => {
      const id = uuidv4();
      teachers.push(id);
      createUser.run(id, `teacher_${grade}${letter}`, hashPassword('teacher123'), 
        `Ð£Ñ‡Ð¸Ñ‚ÐµÐ» ${grade}${letter}`, 'teacher', grade, letter, `ÐšÐ»Ð°ÑÐµÐ½ Ñ€ÑŠÐºÐ¾Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ» ${grade}${letter}`);
    });
  });

  // Students (30 per class = 270 total)
  const students = [];
  const names = ['ÐÐ»ÐµÐºÑÐ°Ð½Ð´ÑŠÑ€', 'Ð“ÐµÐ¾Ñ€Ð³Ð¸', 'Ð”Ð¸Ð¼Ð¸Ñ‚ÑŠÑ€', 'Ð˜Ð²Ð°Ð½', 'ÐœÐ°Ñ€Ð¸Ñ', 'Ð•Ð»ÐµÐ½Ð°', 'ÐÐ½Ð½Ð°', 'Ð’Ð¸ÐºÑ‚Ð¾Ñ€Ð¸Ñ'];
  const lastNames = ['Ð˜Ð²Ð°Ð½Ð¾Ð²', 'ÐŸÐµÑ‚Ñ€Ð¾Ð²', 'Ð“ÐµÐ¾Ñ€Ð³Ð¸ÐµÐ²', 'Ð”Ð¸Ð¼Ð¸Ñ‚Ñ€Ð¾Ð²', 'Ð¥Ñ€Ð¸ÑÑ‚Ð¾Ð²'];
  
  ['10', '11', '12'].forEach(grade => {
    ['Ð°', 'Ð±', 'Ð²'].forEach(letter => {
      for (let i = 1; i <= 30; i++) {
        const id = uuidv4();
        students.push({ id, grade, letter });
        const firstName = names[Math.floor(Math.random() * names.length)];
        const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
        createUser.run(id, `student_${grade}${letter}_${i}`, hashPassword('student123'),
          `${firstName} ${lastName}`, 'student', grade, letter, `Ð£Ñ‡ÐµÐ½Ð¸Ðº ${grade}${letter} ÐºÐ»Ð°Ñ`);
      }
    });
  });

  console.log(`âœ“ Created ${270 + 9 + 2} users`);

  // Create posts
  const createPost = db.prepare(`
    INSERT INTO posts (id, user_id, content, visibility, engagement_score, created_at)
    VALUES (?, ?, ?, ?, ?, NOW())
  `);

  const postTemplates = [
    'ÐšÐ¾Ð¹ Ð·Ð½Ð°Ðµ ÐºÐ¾Ð³Ð° Ñ‰Ðµ Ðµ ÑÐ»ÐµÐ´Ð²Ð°Ñ‰Ð¸ÑÑ‚ Ñ‚ÐµÑÑ‚ Ð¿Ð¾ Ð¼Ð°Ñ‚ÐµÐ¼Ð°Ñ‚Ð¸ÐºÐ°? ðŸ“š',
    'Ð£Ñ‚Ñ€Ðµ Ð¸Ð¼Ð°Ð¼Ðµ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð½Ð¾! Ð£ÑÐ¿ÐµÑ… Ð½Ð° Ð²ÑÐ¸Ñ‡ÐºÐ¸! ðŸ’ª',
    'ÐšÐ¾Ð¹ Ð¸Ð´Ðµ Ð½Ð° Ñ„ÑƒÑ‚Ð±Ð¾Ð»Ð° ÑÐ»ÐµÐ´ ÑƒÑ‡Ð¸Ð»Ð¸Ñ‰Ðµ? âš½',
    'Ð‘Ð»Ð°Ð³Ð¾Ð´Ð°Ñ€Ñ Ð½Ð° ÑƒÑ‡Ð¸Ñ‚ÐµÐ»Ñ Ð·Ð° Ð¸Ð½Ñ‚ÐµÑ€ÐµÑÐ½Ð¸Ñ ÑƒÑ€Ð¾Ðº Ð´Ð½ÐµÑ! ðŸ“–',
    'ÐÑÐºÐ¾Ð¹ Ð´Ð° ÑÐ¿Ð¾Ð´ÐµÐ»Ñ Ð·Ð°Ð¿Ð¸ÑÐºÐ¸Ñ‚Ðµ Ð¾Ñ‚ Ð²Ñ‡ÐµÑ€Ð°? ðŸ“',
    'ÐšÐ¾Ð¹ Ñ‰Ðµ ÑƒÑ‡Ð°ÑÑ‚Ð²Ð° Ð² Ð¾Ð»Ð¸Ð¼Ð¿Ð¸Ð°Ð´Ð°Ñ‚Ð°? ðŸ†',
    'Ð’Ñ€ÐµÐ¼Ðµ Ðµ Ð·Ð° Ð¿Ð¾Ñ‡Ð¸Ð²ÐºÐ°! ðŸŽ‰',
    'Ð˜Ð¼Ð°Ð¼ Ð²ÑŠÐ¿Ñ€Ð¾Ñ Ð·Ð° Ð´Ð¾Ð¼Ð°ÑˆÐ½Ð¾Ñ‚Ð¾. ÐœÐ¾Ð¶Ðµ Ð»Ð¸ Ð½ÑÐºÐ¾Ð¹ Ð´Ð° Ð¿Ð¾Ð¼Ð¾Ð³Ð½Ðµ? ðŸ¤”',
    'Ð•ÐºÑÐºÑƒÑ€Ð·Ð¸ÑÑ‚Ð° Ð±ÐµÑˆÐµ ÑÑ‚Ñ€Ð°Ñ…Ð¾Ñ‚Ð½Ð°! ðŸšŒ',
    'ÐšÐ¾Ð¹ Ð¸ÑÐºÐ° Ð´Ð° Ð¸Ð³Ñ€Ð°ÐµÐ¼ Ð±Ð°ÑÐºÐµÑ‚Ð±Ð¾Ð» Ð² ÑÑŠÐ±Ð¾Ñ‚Ð°? ðŸ€'
  ];

  for (let i = 0; i < 500; i++) {
    const student = students[Math.floor(Math.random() * students.length)];
    const template = postTemplates[Math.floor(Math.random() * postTemplates.length)];
    const visibility = Math.random() > 0.5 ? 'public' : (Math.random() > 0.5 ? 'class' : 'grade');
    const hoursAgo = -Math.floor(Math.random() * 720); // Last 30 days
    
    createPost.run(uuidv4(), student.id, template, visibility, 
      Math.floor(Math.random() * 50), hoursAgo.toString());
  }

  console.log('âœ“ Created 500 posts');

  // Create clubs
  const createClub = db.prepare(`
    INSERT INTO clubs (id, name, description, meeting_schedule, meeting_location, leader_id, status)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `);

  const clubs = [
    { name: 'Ð Ð¾Ð±Ð¾Ñ‚Ð¾Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ°', desc: 'ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¸Ñ€Ð°Ð½Ðµ Ð¸ Ñ€Ð¾Ð±Ð¾Ñ‚Ð¸ÐºÐ°', schedule: 'Ð’Ñ‚ Ð¸ Ð§Ñ‚, 15:00-17:00', location: 'ÐšÐ°Ð±. 401' },
    { name: 'Ð¤ÑƒÑ‚Ð±Ð¾Ð»ÐµÐ½ Ð¾Ñ‚Ð±Ð¾Ñ€', desc: 'Ð£Ñ‡Ð¸Ð»Ð¸Ñ‰ÐµÐ½ Ñ„ÑƒÑ‚Ð±Ð¾Ð»ÐµÐ½ Ð¾Ñ‚Ð±Ð¾Ñ€', schedule: 'ÐŸÐ½, Ð¡Ñ€, ÐŸÑ‚, 16:00-18:00', location: 'Ð¡Ñ‚Ð°Ð´Ð¸Ð¾Ð½' },
    { name: 'Ð›Ð¸Ñ‚ÐµÑ€Ð°Ñ‚ÑƒÑ€ÐµÐ½ ÐºÐ»ÑƒÐ±', desc: 'Ð§ÐµÑ‚ÐµÐ¼ Ð¸ Ð¾Ð±ÑÑŠÐ¶Ð´Ð°Ð¼Ðµ ÐºÐ½Ð¸Ð³Ð¸', schedule: 'Ð’Ñ‚, 15:00-16:30', location: 'Ð‘Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ°' },
    { name: 'Ð”Ñ€Ð°Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÐ½ Ñ‚ÐµÐ°Ñ‚ÑŠÑ€', desc: 'Ð¢ÐµÐ°Ñ‚Ñ€Ð°Ð»Ð½Ð° Ñ‚Ñ€ÑƒÐ¿Ð°', schedule: 'ÐŸÐ½ Ð¸ Ð¡Ñ€, 16:00-18:00', location: 'ÐÐºÑ‚Ð¾Ð²Ð° Ð·Ð°Ð»Ð°' }
  ];

  clubs.forEach(club => {
    const clubId = uuidv4();
    createClub.run(clubId, club.name, club.desc, club.schedule, club.location, teachers[0], 'approved');
    
    // Add members
    const addMember = db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)');
    addMember.run(uuidv4(), clubId, teachers[0], 'leader');
    
    for (let i = 0; i < 15; i++) {
      const student = students[Math.floor(Math.random() * students.length)];
      try {
        addMember.run(uuidv4(), clubId, student.id, 'member');
      } catch (e) { /* Ignore duplicates */ }
    }
  });

  console.log('âœ“ Created clubs');

  // Calendar events
  const createEvent = db.prepare(`
    INSERT INTO calendar_events (id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const admin = db.prepare('SELECT id FROM users WHERE role = ? LIMIT 1').get('admin');
  
  createEvent.run(uuidv4(), 'ÐšÐ¾Ð»ÐµÐ´Ð½Ð° Ð²Ð°ÐºÐ°Ð½Ñ†Ð¸Ñ', 'Ð—Ð¸Ð¼Ð½Ð° Ð¿Ð¾Ñ‡Ð¸Ð²ÐºÐ°', null, '2026-12-23', null, 'holiday', null, null, admin.id);
  createEvent.run(uuidv4(), 'Ð£Ñ‡Ð¸Ð»Ð¸Ñ‰ÐµÐ½ Ð±Ð°Ð»', 'Ð“Ð¾Ð´Ð¸ÑˆÐµÐ½ Ð±Ð°Ð»', 'ÐÐºÑ‚Ð¾Ð²Ð° Ð·Ð°Ð»Ð°', '2026-03-08', '19:00', 'event', null, null, admin.id);
  createEvent.run(uuidv4(), 'Ð¡Ð¿Ð¾Ñ€Ñ‚ÐµÐ½ Ð´ÐµÐ½', 'Ð¡Ð¿Ð¾Ñ€Ñ‚Ð½Ð¸ ÑÑŠÑÑ‚ÐµÐ·Ð°Ð½Ð¸Ñ', 'Ð¡Ñ‚Ð°Ð´Ð¸Ð¾Ð½', '2026-05-15', '10:00', 'event', null, null, admin.id);

  console.log('âœ“ Created calendar events');
  console.log('========================================');
  console.log('Sample data created successfully!');
  console.log('Login: student_11Ð°_1 / student123');
  console.log('========================================');
}

// API Routes

// Auth & Sessions
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    const user = await db.prepare('SELECT * FROM users WHERE username = ?').get(username);
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const stored = user.password;
    const isHash = typeof stored === 'string' && stored.startsWith('$2');
    const ok = isHash ? bcrypt.compareSync(password, stored) : (password === stored);

    if (!ok) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Opportunistic migration: upgrade legacy plaintext passwords to bcrypt on successful login
    if (!isHash) {
      const hashed = bcrypt.hashSync(password, 12);
      await db.prepare('UPDATE users SET password = ? WHERE id = ?').run(hashed, user.id);
      user.password = hashed;
    }
    
    const token = crypto.randomUUID();
    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString();
    
    await db.prepare('INSERT INTO sessions (id, user_id, token, expires_at) VALUES (?, ?, ?, ?)').run(uuidv4(), user.id, token, expires);

    delete user.password;
    res.json({ user, token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/verify-session', async (req, res) => {
  try {
    const { token } = req.body;
    const session = await db.prepare(`
      SELECT u.* FROM sessions s 
      JOIN users u ON s.user_id = u.id 
      WHERE s.token = ? AND s.expires_at > NOW()
    `).get(token);
    
    if (!session) {
      return res.status(401).json({ error: 'Invalid session' });
    }

    delete session.password;
    res.json({ user: session });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/logout', async (req, res) => {
  try {
    const { token } = req.body;
    await db.prepare('DELETE FROM sessions WHERE token = ?').run(token);
    res.json({ message: 'Logged out' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Users
app.get('/api/users/search/:query', async (req, res) => {
  try {
    const query = `%${req.params.query}%`;
    const users = await db.prepare(`
      SELECT id, username, full_name, role, class_grade, class_letter 
      FROM users 
      WHERE full_name LIKE ? OR username LIKE ? 
      LIMIT 20
    `).all(query, query);
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get user profile
app.get('/api/users/:userId/profile', async (req, res) => {
  try {
    const user = await db.prepare(`
      SELECT id, username, email, full_name, role, class_grade, class_letter, bio, profile_picture, created_at
      FROM users
      WHERE id = ?
    `).get(req.params.userId);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Get user's posts
    const posts = await db.prepare(`
      SELECT 
        p.*,
        u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `).all(req.params.userId);
    
    user.posts = posts;
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update user profile
app.patch('/api/users/:userId/profile', async (req, res) => {
  try {
    const { current_user_id, bio, profile_picture } = req.body;
    
    // Can only update your own profile
    if (req.params.userId !== current_user_id) {
      return res.status(403).json({ error: 'Can only update your own profile' });
    }
    
    await db.prepare('UPDATE users SET bio = ?, profile_picture = ? WHERE id = ?').run(bio, profile_picture, req.params.userId);
    
    const user = await db.prepare('SELECT id, username, full_name, role, class_grade, class_letter, bio, profile_picture FROM users WHERE id = ?').get(req.params.userId);
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// User Management (Admin Only)
app.get('/api/users', async (req, res) => {
  try {
    const { admin_id } = req.query;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    const users = await db.prepare(`
      SELECT id, username, email, full_name, role, class_grade, class_letter, created_at
      FROM users
      ORDER BY created_at DESC
    `).all();
    
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/users/create', async (req, res) => {
  try {
    const { admin_id, full_name, email, role, class_grade, class_letter } = req.body;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    // Validate required fields
    if (!full_name || !email || !role) {
      return res.status(400).json({ error: 'Name, email, and role are required' });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }
    
    // Check if email already exists
    const existing = await db.prepare('SELECT id FROM users WHERE email = ?').get(email);
    if (existing) {
      return res.status(400).json({ error: 'Email already exists' });
    }
    
    // Generate username from email (part before @)
    const baseUsername = email.split('@')[0].toLowerCase().replace(/[^a-z0-9]/g, '');
    let username = baseUsername;
    let counter = 1;
    
    // Make username unique
    while (await db.prepare('SELECT id FROM users WHERE username = ?').get(username)) {
      username = `${baseUsername}${counter}`;
      counter++;
    }
    
    // Generate secure random password
    const password = crypto.randomBytes(8).toString('base64').slice(0, 12).replace(/[^a-zA-Z0-9]/g, '') + Math.floor(Math.random() * 100);
    
    // Create user
    const id = uuidv4();
    const hashedPassword = bcrypt.hashSync(password, 12);
    const bio = role === 'student' && class_grade ? 
      `Ð£Ñ‡ÐµÐ½Ð¸Ðº ${class_grade}${class_letter} ÐºÐ»Ð°Ñ` : 
      role === 'teacher' ? 'Ð£Ñ‡Ð¸Ñ‚ÐµÐ»' : '';
    
    await db.prepare(`
      INSERT INTO users (id, username, password, email, full_name, role, class_grade, class_letter, bio)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(id, username, hashedPassword, email, full_name, role, class_grade || null, class_letter || null, bio);
    
    // Return the created user WITH password (only time we send it)
    const user = {
      id,
      username,
      password, // CRITICAL: Send password to admin so they can give it to student
      email,
      full_name,
      role,
      class_grade,
      class_letter
    };
    
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/users/:userId', async (req, res) => {
  try {
    const { admin_id } = req.body;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    // Don't allow deleting yourself
    if (req.params.userId === admin_id) {
      return res.status(400).json({ error: 'Cannot delete yourself' });
    }
    
    // Delete user (cascades to posts, comments, etc.)
    await db.prepare('DELETE FROM users WHERE id = ?').run(req.params.userId);
    
    res.json({ message: 'User deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Feed
app.get('/api/feed/:userId', async (req, res) => {
  try {
    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(req.params.userId);
    
    let posts;
    if (user.role === 'student') {
      posts = await db.prepare(`
        SELECT DISTINCT
          p.*,
          u.full_name, u.role, u.class_grade, u.class_letter,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
          CASE
            WHEN u.class_grade = ? AND u.class_letter = ? THEN 1000
            WHEN u.class_grade = ? THEN 500
            ELSE 10
          END as priority
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE 
          p.visibility = 'public' OR
          (p.visibility = 'grade' AND u.class_grade = ?) OR
          (p.visibility = 'class' AND u.class_grade = ? AND u.class_letter = ?)
        ORDER BY priority DESC, p.created_at DESC
        LIMIT 100
      `).all(user.class_grade, user.class_letter, user.class_grade, user.class_grade, user.class_grade, user.class_letter);
    } else {
      posts = await db.prepare(`
        SELECT 
          p.*,
          u.full_name, u.role, u.class_grade, u.class_letter,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE p.visibility = 'public'
        ORDER BY p.created_at DESC
        LIMIT 100
      `).all();
    }

    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Posts
app.get('/api/posts/:postId', async (req, res) => {
  try {
    const post = await db.prepare(`
      SELECT 
        p.*,
        u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.id = ?
    `).get(req.params.postId);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/posts', async (req, res) => {
  try {
    const { user_id, content, image_url, visibility, attachments } = req.body;
    const id = uuidv4();
    const created_at = new Date().toISOString();
    
    await db.prepare('INSERT INTO posts (id, user_id, content, image_url, visibility, created_at) VALUES (?, ?, ?, ?, ?, ?)').run(id, user_id, content, image_url || null, visibility || 'public', created_at);

    // Parse mentions and notify
    const mentions = parseMentions(content);
    for (const username of mentions) {
      const mentionedUser = await db.prepare('SELECT id FROM users WHERE username = ?').get(username);
      if (mentionedUser && mentionedUser.id !== user_id) {
        await createNotification(mentionedUser.id, 'mention', user_id, id);
      }
    }

    // Handle attachments
    if (attachments && Array.isArray(attachments)) {
      for (const att of attachments) {
        await db.prepare('INSERT INTO post_attachments (id, post_id, filename, file_url, file_type, file_size) VALUES (?, ?, ?, ?, ?, ?)').run(
          uuidv4(),
          id,
          att.filename,
          att.file_url,
          att.file_type,
          att.file_size || 0
        );
      }
    }

    const post = await db.prepare(`
      SELECT p.*, u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        0 as like_count, 0 as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.id = ?
    `).get(id);

    res.status(201).json(post);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/posts/:id', async (req, res) => {
  try {
    const { user_id } = req.body;
    const post = await db.prepare('SELECT * FROM posts WHERE id = ?').get(req.params.id);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }

    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);
    
    if (post.user_id !== user_id && user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized' });
    }

    await db.prepare('DELETE FROM posts WHERE id = ?').run(req.params.id);
    res.json({ message: 'Post deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Likes
app.post('/api/posts/:postId/like', async (req, res) => {
  try {
    const { postId } = req.params;
    const { user_id } = req.body;

    const existing = await db.prepare('SELECT id FROM likes WHERE post_id = ? AND user_id = ?').get(postId, user_id);

    if (existing) {
      await db.prepare('DELETE FROM likes WHERE id = ?').run(existing.id);
      res.json({ liked: false });
    } else {
      await db.prepare('INSERT INTO likes (id, post_id, user_id) VALUES (?, ?, ?)').run(uuidv4(), postId, user_id);
      
      // Create notification
      const post = await db.prepare('SELECT user_id FROM posts WHERE id = ?').get(postId);
      if (post) {
        createNotification(post.user_id, 'like', user_id, postId);
      }
      
      res.json({ liked: true });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/posts/:postId/liked/:userId', async (req, res) => {
  try {
    const like = await db.prepare('SELECT id FROM likes WHERE post_id = ? AND user_id = ?').get(req.params.postId, req.params.userId);
    res.json({ liked: !!like });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Comments
app.get('/api/posts/:postId/comments', async (req, res) => {
  try {
    const comments = await db.prepare(`
      SELECT c.*, u.full_name, u.role, u.class_grade, u.class_letter
      FROM comments c
      JOIN users u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `).all(req.params.postId);
    res.json(comments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/posts/:postId/comments', async (req, res) => {
  try {
    const { user_id, content } = req.body;
    const id = uuidv4();
    const created_at = new Date().toISOString();
    
    await db.prepare('INSERT INTO comments (id, post_id, user_id, content, created_at) VALUES (?, ?, ?, ?, ?)').run(id, req.params.postId, user_id, content, created_at);

    // Notify post owner
    const post = await db.prepare('SELECT user_id FROM posts WHERE id = ?').get(req.params.postId);
    if (post) {
      createNotification(post.user_id, 'comment', user_id, req.params.postId, id);
    }
    
    // Parse mentions and notify
    const mentions = parseMentions(content);
    for (const username of mentions) {
      const mentionedUser = await db.prepare('SELECT id FROM users WHERE username = ?').get(username);
      if (mentionedUser && mentionedUser.id !== user_id) {
        await createNotification(mentionedUser.id, 'mention', user_id, req.params.postId);
      }
    }


    const comment = await db.prepare(`
      SELECT c.*, u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture
      FROM comments c
      JOIN users u ON c.user_id = u.id
      WHERE c.id = ?
    `).get(id);

    res.status(201).json(comment);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/comments/:id', async (req, res) => {
  try {
    const { user_id } = req.body;
    const comment = await db.prepare('SELECT * FROM comments WHERE id = ?').get(req.params.id);
    
    if (!comment) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);

    if (comment.user_id !== user_id && user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized' });
    }

    await db.prepare('DELETE FROM comments WHERE id = ?').run(req.params.id);
    res.json({ message: 'Comment deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Calendar
app.get('/api/calendar', async (req, res) => {
  try {
    const { userId } = req.query;
    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(userId);

    let events;
    if (user && user.role === 'student') {
      events = await db.prepare(`
        SELECT e.*, u.full_name as created_by_name
        FROM calendar_events e
        JOIN users u ON e.created_by = u.id
        WHERE 
          (e.class_grade IS NULL) OR
          (e.class_grade = ? AND e.class_letter = ?)
        ORDER BY e.event_date ASC
      `).all(user.class_grade, user.class_letter);
    } else {
      events = await db.prepare(`
        SELECT e.*, u.full_name as created_by_name
        FROM calendar_events e
        JOIN users u ON e.created_by = u.id
        ORDER BY e.event_date ASC
      `).all();
    }

    res.json(events);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/calendar/:id', async (req, res) => {
  try {
    const event = await db.prepare(`
      SELECT e.*, u.full_name as created_by_name
      FROM calendar_events e
      JOIN users u ON e.created_by = u.id
      WHERE e.id = ?
    `).get(req.params.id);
    
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }

    res.json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/calendar', async (req, res) => {
  try {
    const { title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by } = req.body;
    const id = uuidv4();
    
    await db.prepare(`
      INSERT INTO calendar_events (id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by);

    const event = await db.prepare('SELECT * FROM calendar_events WHERE id = ?').get(id);
    res.status(201).json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Clubs
app.get('/api/clubs', async (req, res) => {
  try {
    const clubs = await db.prepare(`
      SELECT c.*, u.full_name as leader_name,
        (SELECT COUNT(*) FROM club_members WHERE club_id = c.id) as member_count
      FROM clubs c
      JOIN users u ON c.leader_id = u.id
      WHERE c.status = 'approved'
      ORDER BY c.name
    `).all();
    res.json(clubs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/clubs/:id', async (req, res) => {
  try {
    const club = await db.prepare(`
      SELECT c.*, u.full_name as leader_name,
        (SELECT COUNT(*) FROM club_members WHERE club_id = c.id) as member_count
      FROM clubs c
      JOIN users u ON c.leader_id = u.id
      WHERE c.id = ?
    `).get(req.params.id);

    if (!club) {
      return res.status(404).json({ error: 'Club not found' });
    }

    const members = await db.prepare(`
      SELECT u.id, u.full_name, u.role, u.class_grade, u.class_letter, cm.role as member_role
      FROM club_members cm
      JOIN users u ON cm.user_id = u.id
      WHERE cm.club_id = ?
      ORDER BY cm.role DESC, u.full_name
    `).all(req.params.id);

    club.members = members;
    res.json(club);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/clubs/:clubId/is-member/:userId', async (req, res) => {
  try {
    const member = await db.prepare('SELECT * FROM club_members WHERE club_id = ? AND user_id = ?').get(req.params.clubId, req.params.userId);
    res.json({ isMember: !!member });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/clubs', async (req, res) => {
  try {
    const { name, description, meeting_schedule, meeting_location, leader_id } = req.body;
    const id = uuidv4();
    
    await db.prepare('INSERT INTO clubs (id, name, description, meeting_schedule, meeting_location, leader_id) VALUES (?, ?, ?, ?, ?, ?)').run(id, name, description, meeting_schedule, meeting_location, leader_id);

    await db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)').run(uuidv4(), id, leader_id, 'leader');

    const club = await db.prepare('SELECT * FROM clubs WHERE id = ?').get(id);
    res.status(201).json(club);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/clubs/:clubId/join', async (req, res) => {
  try {
    const { user_id } = req.body;
    const existing = await db.prepare('SELECT * FROM club_members WHERE club_id = ? AND user_id = ?').get(req.params.clubId, user_id);

    if (existing) {
      return res.status(400).json({ error: 'Already a member' });
    }

    await db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)').run(uuidv4(), req.params.clubId, user_id, 'member');

    res.json({ message: 'Joined club' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/clubs/:clubId/leave', async (req, res) => {
  try {
    const { user_id } = req.body;
    
    await db.prepare('DELETE FROM club_members WHERE club_id = ? AND user_id = ?').run(req.params.clubId, user_id);

    res.json({ message: 'Left club' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Messages
app.get('/api/messages/conversations/:userId', async (req, res) => {
  try {
    const conversations = await db.prepare(`
      SELECT DISTINCT c.*,
        (SELECT content FROM messages WHERE conversation_id = c.id ORDER BY created_at DESC LIMIT 1) as last_message
      FROM conversations c
      JOIN conversation_participants cp ON c.id = cp.conversation_id
      WHERE cp.user_id = ?
      ORDER BY c.created_at DESC
    `).all(req.params.userId);

    for (const conv of conversations) {
      if (!conv.is_group) {
        const other = await db.prepare(`
          SELECT u.full_name
          FROM conversation_participants cp
          JOIN users u ON cp.user_id = u.id
          WHERE cp.conversation_id = ? AND cp.user_id != ?
        `).get(conv.id, req.params.userId);

        conv.name = other ? other.full_name : 'Ð Ð°Ð·Ð³Ð¾Ð²Ð¾Ñ€';
      }
    }

    res.json(conversations);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/messages/:conversationId', async (req, res) => {
  try {
    const messages = await db.prepare(`
      SELECT m.*, u.full_name as sender_name
      FROM messages m
      JOIN users u ON m.sender_id = u.id
      WHERE m.conversation_id = ?
      ORDER BY m.created_at ASC
    `).all(req.params.conversationId);

    res.json(messages);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/messages/conversations', async (req, res) => {
  try {
    const { participants, is_group, name, created_by } = req.body;
    const convId = uuidv4();
    
    await db.prepare('INSERT INTO conversations (id, name, is_group, created_by) VALUES (?, ?, ?, ?)').run(convId, name || null, !!is_group, created_by || null);

    for (const userId of participants) {
      await db.prepare('INSERT INTO conversation_participants (id, conversation_id, user_id) VALUES (?, ?, ?)').run(uuidv4(), convId, userId);
    }

    const conversation = await db.prepare('SELECT * FROM conversations WHERE id = ?').get(convId);
    res.status(201).json(conversation);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/messages', async (req, res) => {
  try {
    const { sender_id, conversation_id, content } = req.body;
    const id = uuidv4();
    
    await db.prepare('INSERT INTO messages (id, sender_id, conversation_id, content) VALUES (?, ?, ?, ?)').run(id, sender_id, conversation_id, content);

    const message = await db.prepare('SELECT * FROM messages WHERE id = ?').get(id);
    res.status(201).json(message);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// NOTIFICATIONS
app.get('/api/notifications/:userId', async (req, res) => {
  try {
    const notifications = await db.prepare(`
      SELECT 
        n.*,
        u.full_name as actor_name,
        u.username as actor_username,
        u.profile_picture as actor_picture,
        p.content as post_content
      FROM notifications n
      JOIN users u ON n.actor_id = u.id
      LEFT JOIN posts p ON n.post_id = p.id
      WHERE n.user_id = ?
      ORDER BY n.created_at DESC
      LIMIT 50
    `).all(req.params.userId);
    
    res.json(notifications);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/notifications/:userId/unread-count', async (req, res) => {
  try {
    const result = await db.prepare('SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND is_read = 0').get(req.params.userId);
    res.json({ count: result.count });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/notifications/:notificationId/read', async (req, res) => {
  try {
    await db.prepare('UPDATE notifications SET is_read = 1 WHERE id = ?').run(req.params.notificationId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/notifications/:userId/read-all', async (req, res) => {
  try {
    await db.prepare('UPDATE notifications SET is_read = 1 WHERE user_id = ?').run(req.params.userId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ATTACHMENTS
app.get('/api/posts/:postId/attachments', async (req, res) => {
  try {
    const attachments = await db.prepare('SELECT * FROM post_attachments WHERE post_id = ? ORDER BY created_at ASC').all(req.params.postId);
    res.json(attachments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// MENTION SEARCH
app.get('/api/users/mention-search/:query', async (req, res) => {
  try {
    const query = `${req.params.query}%`;
    const users = await db.prepare(`
      SELECT id, username, full_name, profile_picture, role, class_grade, class_letter
      FROM users 
      WHERE username LIKE ? OR full_name LIKE ?
      ORDER BY username ASC
      LIMIT 10
    `).all(query, query);
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/health', async (req, res) => {
  res.json({ status: 'OK', message: 'School Social Network API' });
});

// Start server
(async () => {
  try {
await initDB();

// If Postgres is empty, bootstrap it either by migrating the bundled SQLite DB
// (same initial state as the SQLite version) or by running the built-in seed.
const countRow = await db.prepare('SELECT COUNT(*)::int AS count FROM users').get();
if ((countRow?.count || 0) === 0) {
  const auto = (process.env.AUTO_MIGRATE_SQLITE || 'true').toLowerCase() !== 'false';
  const sqlitePath = process.env.SQLITE_PATH || path.join(__dirname, 'sqlite_backup', 'school.db');
  if (auto && fs.existsSync(sqlitePath)) {
    console.log('No users found in Postgres. Migrating from SQLite:', sqlitePath);
    await migrateSqliteToPostgres({ sqlitePath, pg: db });
    console.log('âœ“ SQLite â†’ Postgres migration finished');
  } else {
    console.log('No users found in Postgres. Seeding sample data...');
    await seedData();
    console.log('âœ“ Seed finished');
  }
}
  } catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
})();
