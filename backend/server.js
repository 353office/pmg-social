require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { createDB } = require('./db');
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const fs = require('fs');
const path = require('path');
const { migrateSqliteToPostgres } = require('./scripts/sqliteMigrator');

const app = express();
app.get("/", (req, res) => res.status(200).send("OK"));
app.get("/health", (req, res) => res.status(200).json({ ok: true }));

const PORT = process.env.PORT || 3000;
app.listen(PORT, "0.0.0.0", () => {
  console.log(`
listening on ${PORT}

Server: http://localhost:${PORT}
API:    http://localhost:${PORT}/api

Example logins:  student_11–∞_1 / student123
        teacher_11–∞ / teacher123
        admin / admin123
`);
    });
    
app.use(cors({
  origin: (origin, cb) => {
    const allowed = (process.env.CORS_ORIGIN || '').split(',').map(s => s.trim()).filter(Boolean);
    if (!origin) return cb(null, true); // server-to-server / curl
    if (allowed.length === 0) return cb(null, true); // default allow all (dev)
    return cb(null, allowed.includes(origin));
  },
  credentials: true,
}));
app.use(express.json());

// Initialize database (PostgreSQL via DATABASE_URL)
const db = createDB();

async function initDB() {
  // NOTE: UUIDs are generated by the application (uuidv4).
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id UUID PRIMARY KEY,
      username TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      email TEXT UNIQUE,
      full_name TEXT NOT NULL,
      role TEXT NOT NULL,
      class_grade TEXT,
      class_letter TEXT,
      bio TEXT,
      profile_picture TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS sessions (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token UUID UNIQUE NOT NULL,
      expires_at TIMESTAMPTZ NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS posts (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      image_url TEXT,
      visibility TEXT NOT NULL DEFAULT 'public',
      engagement_score INTEGER NOT NULL DEFAULT 0,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS likes (
      id UUID PRIMARY KEY,
      post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(post_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS comments (
      id UUID PRIMARY KEY,
      post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS calendar_events (
      id UUID PRIMARY KEY,
      title TEXT NOT NULL,
      description TEXT,
      location TEXT,
      event_date TEXT NOT NULL,
      event_time TEXT,
      event_type TEXT,
      class_grade TEXT,
      class_letter TEXT,
      created_by UUID NOT NULL REFERENCES users(id),
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS clubs (
      id UUID PRIMARY KEY,
      name TEXT NOT NULL,
      description TEXT,
      meeting_schedule TEXT,
      meeting_location TEXT,
      leader_id UUID NOT NULL REFERENCES users(id),
      status TEXT NOT NULL DEFAULT 'approved',
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS club_members (
      id UUID PRIMARY KEY,
      club_id UUID NOT NULL REFERENCES clubs(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      role TEXT NOT NULL DEFAULT 'member',
      joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(club_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS conversations (
      id UUID PRIMARY KEY,
      name TEXT,
      is_group BOOLEAN NOT NULL DEFAULT FALSE,
      created_by UUID REFERENCES users(id),
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS conversation_participants (
      id UUID PRIMARY KEY,
      conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(conversation_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS messages (
      id UUID PRIMARY KEY,
      conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
      sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      message_type TEXT NOT NULL DEFAULT 'text',
      attachment_url TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS notifications (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      type TEXT NOT NULL,
      title TEXT NOT NULL,
      message TEXT NOT NULL,
      related_id UUID,
      is_read BOOLEAN NOT NULL DEFAULT FALSE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS attachments (
      id UUID PRIMARY KEY,
      user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      file_name TEXT NOT NULL,
      file_type TEXT NOT NULL,
      file_size INTEGER NOT NULL,
      file_url TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}


async function createNotification(userId, type, actorId, postId = null, commentId = null) {
  if (userId === actorId) return;
  try {
    const id = uuidv4();
    await db.prepare(`
      INSERT INTO notifications (id, user_id, type, actor_id, post_id, comment_id)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(id, userId, type, actorId, postId, commentId);
  } catch (error) {
    console.error('Notification error:', error);
  }
}

function parseMentions(content) {
  if (!content) return [];
  const mentionRegex = /@(\w+)/g;
  const mentions = [];
  let match;
  while ((match = mentionRegex.exec(content)) !== null) {
    mentions.push(match[1]);
  }
  return mentions;
}

async function seedData() {
  const count = await db.prepare('SELECT COUNT(*) as count FROM users').get();
  if (count.count > 0) {
    console.log('‚úì Data already exists');
    return;
  }

  console.log('Creating sample data...');

  const hashPassword = (p) => bcrypt.hashSync(p, 12);

  // Create users
  const createUser = await db.prepare(`
    INSERT INTO users (id, username, password, full_name, role, class_grade, class_letter, bio)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  // Admin
  createUser.run(uuidv4(), 'admin', hashPassword('admin123'), '–ò–≤–∞–Ω –ì–µ–æ—Ä–≥–∏–µ–≤', 'admin', null, null, '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä');

  // Moderator
  createUser.run(uuidv4(), 'director', hashPassword('director123'), '–ú–∞—Ä–∏—è –î–∏–º–∏—Ç—Ä–æ–≤–∞', 'moderator', null, null, '–î–∏—Ä–µ–∫—Ç–æ—Ä');

  // Teachers
  const teachers = [];
  ['10', '11', '12'].forEach(grade => {
    ['–∞', '–±', '–≤'].forEach(letter => {
      const id = uuidv4();
      teachers.push(id);
      createUser.run(id, `teacher_${grade}${letter}`, hashPassword('teacher123'), 
        `–£—á–∏—Ç–µ–ª ${grade}${letter}`, 'teacher', grade, letter, `–ö–ª–∞—Å–µ–Ω —Ä—ä–∫–æ–≤–æ–¥–∏—Ç–µ–ª ${grade}${letter}`);
    });
  });

  // Students (30 per class = 270 total)
  const students = [];
  const names = ['–ê–ª–µ–∫—Å–∞–Ω–¥—ä—Ä', '–ì–µ–æ—Ä–≥–∏', '–î–∏–º–∏—Ç—ä—Ä', '–ò–≤–∞–Ω', '–ú–∞—Ä–∏—è', '–ï–ª–µ–Ω–∞', '–ê–Ω–Ω–∞', '–í–∏–∫—Ç–æ—Ä–∏—è'];
  const lastNames = ['–ò–≤–∞–Ω–æ–≤', '–ü–µ—Ç—Ä–æ–≤', '–ì–µ–æ—Ä–≥–∏–µ–≤', '–î–∏–º–∏—Ç—Ä–æ–≤', '–•—Ä–∏—Å—Ç–æ–≤'];
  
  ['10', '11', '12'].forEach(grade => {
    ['–∞', '–±', '–≤'].forEach(letter => {
      for (let i = 1; i <= 30; i++) {
        const id = uuidv4();
        students.push({ id, grade, letter });
        const firstName = names[Math.floor(Math.random() * names.length)];
        const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
        createUser.run(id, `student_${grade}${letter}_${i}`, hashPassword('student123'),
          `${firstName} ${lastName}`, 'student', grade, letter, `–£—á–µ–Ω–∏–∫ ${grade}${letter} –∫–ª–∞—Å`);
      }
    });
  });

  console.log(`‚úì Created ${270 + 9 + 2} users`);

  // Create posts
  const createPost = db.prepare(`
    INSERT INTO posts (id, user_id, content, visibility, engagement_score, created_at)
    VALUES (?, ?, ?, ?, ?, NOW())
  `);

  const postTemplates = [
    '–ö–æ–π –∑–Ω–∞–µ –∫–æ–≥–∞ —â–µ –µ —Å–ª–µ–¥–≤–∞—â–∏—è—Ç —Ç–µ—Å—Ç –ø–æ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞? üìö',
    '–£—Ç—Ä–µ –∏–º–∞–º–µ –∫–æ–Ω—Ç—Ä–æ–ª–Ω–æ! –£—Å–ø–µ—Ö –Ω–∞ –≤—Å–∏—á–∫–∏! üí™',
    '–ö–æ–π –∏–¥–µ –Ω–∞ —Ñ—É—Ç–±–æ–ª–∞ —Å–ª–µ–¥ —É—á–∏–ª–∏—â–µ? ‚öΩ',
    '–ë–ª–∞–≥–æ–¥–∞—Ä—è –Ω–∞ —É—á–∏—Ç–µ–ª—è –∑–∞ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∏—è —É—Ä–æ–∫ –¥–Ω–µ—Å! üìñ',
    '–ù—è–∫–æ–π –¥–∞ —Å–ø–æ–¥–µ–ª—è –∑–∞–ø–∏—Å–∫–∏—Ç–µ –æ—Ç –≤—á–µ—Ä–∞? üìù',
    '–ö–æ–π —â–µ —É—á–∞—Å—Ç–≤–∞ –≤ –æ–ª–∏–º–ø–∏–∞–¥–∞—Ç–∞? üèÜ',
    '–í—Ä–µ–º–µ –µ –∑–∞ –ø–æ—á–∏–≤–∫–∞! üéâ',
    '–ò–º–∞–º –≤—ä–ø—Ä–æ—Å –∑–∞ –¥–æ–º–∞—à–Ω–æ—Ç–æ. –ú–æ–∂–µ –ª–∏ –Ω—è–∫–æ–π –¥–∞ –ø–æ–º–æ–≥–Ω–µ? ü§î',
    '–ï–∫—Å–∫—É—Ä–∑–∏—è—Ç–∞ –±–µ—à–µ —Å—Ç—Ä–∞—Ö–æ—Ç–Ω–∞! üöå',
    '–ö–æ–π –∏—Å–∫–∞ –¥–∞ –∏–≥—Ä–∞–µ–º –±–∞—Å–∫–µ—Ç–±–æ–ª –≤ —Å—ä–±–æ—Ç–∞? üèÄ'
  ];

  for (let i = 0; i < 500; i++) {
    const student = students[Math.floor(Math.random() * students.length)];
    const template = postTemplates[Math.floor(Math.random() * postTemplates.length)];
    const visibility = Math.random() > 0.5 ? 'public' : (Math.random() > 0.5 ? 'class' : 'grade');
    const hoursAgo = -Math.floor(Math.random() * 720); // Last 30 days
    
    createPost.run(uuidv4(), student.id, template, visibility, 
      Math.floor(Math.random() * 50), hoursAgo.toString());
  }

  console.log('‚úì Created 500 posts');

  // Create clubs
  const createClub = db.prepare(`
    INSERT INTO clubs (id, name, description, meeting_schedule, meeting_location, leader_id, status)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `);

  const clubs = [
    { name: '–†–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞', desc: '–ü—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –∏ —Ä–æ–±–æ—Ç–∏–∫–∞', schedule: '–í—Ç –∏ –ß—Ç, 15:00-17:00', location: '–ö–∞–±. 401' },
    { name: '–§—É—Ç–±–æ–ª–µ–Ω –æ—Ç–±–æ—Ä', desc: '–£—á–∏–ª–∏—â–µ–Ω —Ñ—É—Ç–±–æ–ª–µ–Ω –æ—Ç–±–æ—Ä', schedule: '–ü–Ω, –°—Ä, –ü—Ç, 16:00-18:00', location: '–°—Ç–∞–¥–∏–æ–Ω' },
    { name: '–õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–µ–Ω –∫–ª—É–±', desc: '–ß–µ—Ç–µ–º –∏ –æ–±—Å—ä–∂–¥–∞–º–µ –∫–Ω–∏–≥–∏', schedule: '–í—Ç, 15:00-16:30', location: '–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞' },
    { name: '–î—Ä–∞–º–∞—Ç–∏—á–µ–Ω —Ç–µ–∞—Ç—ä—Ä', desc: '–¢–µ–∞—Ç—Ä–∞–ª–Ω–∞ —Ç—Ä—É–ø–∞', schedule: '–ü–Ω –∏ –°—Ä, 16:00-18:00', location: '–ê–∫—Ç–æ–≤–∞ –∑–∞–ª–∞' }
  ];

  clubs.forEach(club => {
    const clubId = uuidv4();
    createClub.run(clubId, club.name, club.desc, club.schedule, club.location, teachers[0], 'approved');
    
    // Add members
    const addMember = db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)');
    addMember.run(uuidv4(), clubId, teachers[0], 'leader');
    
    for (let i = 0; i < 15; i++) {
      const student = students[Math.floor(Math.random() * students.length)];
      try {
        addMember.run(uuidv4(), clubId, student.id, 'member');
      } catch (e) { /* Ignore duplicates */ }
    }
  });

  console.log('‚úì Created clubs');

  // Calendar events
  const createEvent = db.prepare(`
    INSERT INTO calendar_events (id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const admin = db.prepare('SELECT id FROM users WHERE role = ? LIMIT 1').get('admin');
  
  createEvent.run(uuidv4(), '–ö–æ–ª–µ–¥–Ω–∞ –≤–∞–∫–∞–Ω—Ü–∏—è', '–ó–∏–º–Ω–∞ –ø–æ—á–∏–≤–∫–∞', null, '2026-12-23', null, 'holiday', null, null, admin.id);
  createEvent.run(uuidv4(), '–£—á–∏–ª–∏—â–µ–Ω –±–∞–ª', '–ì–æ–¥–∏—à–µ–Ω –±–∞–ª', '–ê–∫—Ç–æ–≤–∞ –∑–∞–ª–∞', '2026-03-08', '19:00', 'event', null, null, admin.id);
  createEvent.run(uuidv4(), '–°–ø–æ—Ä—Ç–µ–Ω –¥–µ–Ω', '–°–ø–æ—Ä—Ç–Ω–∏ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è', '–°—Ç–∞–¥–∏–æ–Ω', '2026-05-15', '10:00', 'event', null, null, admin.id);

  console.log('‚úì Created calendar events');
  console.log('========================================');
  console.log('Sample data created successfully!');
  console.log('Login: student_11–∞_1 / student123');
  console.log('========================================');
}

// API Routes

// Auth & Sessions
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    const user = await db.prepare('SELECT * FROM users WHERE username = ?').get(username);
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const stored = user.password;
    const isHash = typeof stored === 'string' && stored.startsWith('$2');
    const ok = isHash ? bcrypt.compareSync(password, stored) : (password === stored);

    if (!ok) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Opportunistic migration: upgrade legacy plaintext passwords to bcrypt on successful login
    if (!isHash) {
      const hashed = bcrypt.hashSync(password, 12);
      await db.prepare('UPDATE users SET password = ? WHERE id = ?').run(hashed, user.id);
      user.password = hashed;
    }
    
    const token = crypto.randomUUID();
    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString();
    
    await db.prepare('INSERT INTO sessions (id, user_id, token, expires_at) VALUES (?, ?, ?, ?)').run(uuidv4(), user.id, token, expires);

    delete user.password;
    res.json({ user, token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/verify-session', async (req, res) => {
  try {
    const { token } = req.body;
    const session = await db.prepare(`
      SELECT u.* FROM sessions s 
      JOIN users u ON s.user_id = u.id 
      WHERE s.token = ? AND s.expires_at > NOW()
    `).get(token);
    
    if (!session) {
      return res.status(401).json({ error: 'Invalid session' });
    }

    delete session.password;
    res.json({ user: session });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/logout', async (req, res) => {
  try {
    const { token } = req.body;
    await db.prepare('DELETE FROM sessions WHERE token = ?').run(token);
    res.json({ message: 'Logged out' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Users
app.get('/api/users/search/:query', async (req, res) => {
  try {
    const query = `%${req.params.query}%`;
    const users = await db.prepare(`
      SELECT id, username, full_name, role, class_grade, class_letter 
      FROM users 
      WHERE full_name LIKE ? OR username LIKE ? 
      LIMIT 20
    `).all(query, query);
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get user profile
app.get('/api/users/:userId/profile', async (req, res) => {
  try {
    const user = await db.prepare(`
      SELECT id, username, email, full_name, role, class_grade, class_letter, bio, profile_picture, created_at
      FROM users
      WHERE id = ?
    `).get(req.params.userId);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Get user's posts
    const posts = await db.prepare(`
      SELECT 
        p.*,
        u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `).all(req.params.userId);
    
    user.posts = posts;
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update user profile
app.patch('/api/users/:userId/profile', async (req, res) => {
  try {
    const { current_user_id, bio, profile_picture } = req.body;
    
    // Can only update your own profile
    if (req.params.userId !== current_user_id) {
      return res.status(403).json({ error: 'Can only update your own profile' });
    }
    
    await db.prepare('UPDATE users SET bio = ?, profile_picture = ? WHERE id = ?').run(bio, profile_picture, req.params.userId);
    
    const user = await db.prepare('SELECT id, username, full_name, role, class_grade, class_letter, bio, profile_picture FROM users WHERE id = ?').get(req.params.userId);
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// User Management (Admin Only)
app.get('/api/users', async (req, res) => {
  try {
    const { admin_id } = req.query;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    const users = await db.prepare(`
      SELECT id, username, email, full_name, role, class_grade, class_letter, created_at
      FROM users
      ORDER BY created_at DESC
    `).all();
    
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/users/create', async (req, res) => {
  try {
    const { admin_id, full_name, email, role, class_grade, class_letter } = req.body;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    // Validate required fields
    if (!full_name || !email || !role) {
      return res.status(400).json({ error: 'Name, email, and role are required' });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }
    
    // Check if email already exists
    const existing = await db.prepare('SELECT id FROM users WHERE email = ?').get(email);
    if (existing) {
      return res.status(400).json({ error: 'Email already exists' });
    }
    
    // Generate username from email (part before @)
    const baseUsername = email.split('@')[0].toLowerCase().replace(/[^a-z0-9]/g, '');
    let username = baseUsername;
    let counter = 1;
    
    // Make username unique
    while (await db.prepare('SELECT id FROM users WHERE username = ?').get(username)) {
      username = `${baseUsername}${counter}`;
      counter++;
    }
    
    // Generate secure random password
    const password = crypto.randomBytes(8).toString('base64').slice(0, 12).replace(/[^a-zA-Z0-9]/g, '') + Math.floor(Math.random() * 100);
    
    // Create user
    const id = uuidv4();
    const hashedPassword = bcrypt.hashSync(password, 12);
    const bio = role === 'student' && class_grade ? 
      `–£—á–µ–Ω–∏–∫ ${class_grade}${class_letter} –∫–ª–∞—Å` : 
      role === 'teacher' ? '–£—á–∏—Ç–µ–ª' : '';
    
    await db.prepare(`
      INSERT INTO users (id, username, password, email, full_name, role, class_grade, class_letter, bio)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(id, username, hashedPassword, email, full_name, role, class_grade || null, class_letter || null, bio);
    
    // Return the created user WITH password (only time we send it)
    const user = {
      id,
      username,
      password, // CRITICAL: Send password to admin so they can give it to student
      email,
      full_name,
      role,
      class_grade,
      class_letter
    };
    
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/users/:userId', async (req, res) => {
  try {
    const { admin_id } = req.body;
    
    // Verify admin
    const admin = await db.prepare('SELECT * FROM users WHERE id = ? AND role = ?').get(admin_id, 'admin');
    if (!admin) {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    // Don't allow deleting yourself
    if (req.params.userId === admin_id) {
      return res.status(400).json({ error: 'Cannot delete yourself' });
    }
    
    // Delete user (cascades to posts, comments, etc.)
    await db.prepare('DELETE FROM users WHERE id = ?').run(req.params.userId);
    
    res.json({ message: 'User deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Feed
app.get('/api/feed/:userId', async (req, res) => {
  try {
    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(req.params.userId);
    
    let posts;
    if (user.role === 'student') {
      posts = await db.prepare(`
        SELECT DISTINCT
          p.*,
          u.full_name, u.role, u.class_grade, u.class_letter,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
          CASE
            WHEN u.class_grade = ? AND u.class_letter = ? THEN 1000
            WHEN u.class_grade = ? THEN 500
            ELSE 10
          END as priority
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE 
          p.visibility = 'public' OR
          (p.visibility = 'grade' AND u.class_grade = ?) OR
          (p.visibility = 'class' AND u.class_grade = ? AND u.class_letter = ?)
        ORDER BY priority DESC, p.created_at DESC
        LIMIT 100
      `).all(user.class_grade, user.class_letter, user.class_grade, user.class_grade, user.class_grade, user.class_letter);
    } else {
      posts = await db.prepare(`
        SELECT 
          p.*,
          u.full_name, u.role, u.class_grade, u.class_letter,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE p.visibility = 'public'
        ORDER BY p.created_at DESC
        LIMIT 100
      `).all();
    }

    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Posts
app.get('/api/posts/:postId', async (req, res) => {
  try {
    const post = await db.prepare(`
      SELECT 
        p.*,
        u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.id = ?
    `).get(req.params.postId);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/posts', async (req, res) => {
  try {
    const { user_id, content, image_url, visibility, attachments } = req.body;
    const id = uuidv4();
    const created_at = new Date().toISOString();
    
    await db.prepare('INSERT INTO posts (id, user_id, content, image_url, visibility, created_at) VALUES (?, ?, ?, ?, ?, ?)').run(id, user_id, content, image_url || null, visibility || 'public', created_at);

    // Parse mentions and notify
    const mentions = parseMentions(content);
    for (const username of mentions) {
      const mentionedUser = await db.prepare('SELECT id FROM users WHERE username = ?').get(username);
      if (mentionedUser && mentionedUser.id !== user_id) {
        await createNotification(mentionedUser.id, 'mention', user_id, id);
      }
    }

    // Handle attachments
    if (attachments && Array.isArray(attachments)) {
      for (const att of attachments) {
        await db.prepare('INSERT INTO post_attachments (id, post_id, filename, file_url, file_type, file_size) VALUES (?, ?, ?, ?, ?, ?)').run(
          uuidv4(),
          id,
          att.filename,
          att.file_url,
          att.file_type,
          att.file_size || 0
        );
      }
    }

    const post = await db.prepare(`
      SELECT p.*, u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture,
        0 as like_count, 0 as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.id = ?
    `).get(id);

    res.status(201).json(post);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/posts/:id', async (req, res) => {
  try {
    const { user_id } = req.body;
    const post = await db.prepare('SELECT * FROM posts WHERE id = ?').get(req.params.id);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }

    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);
    
    if (post.user_id !== user_id && user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized' });
    }

    await db.prepare('DELETE FROM posts WHERE id = ?').run(req.params.id);
    res.json({ message: 'Post deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Likes
app.post('/api/posts/:postId/like', async (req, res) => {
  try {
    const { postId } = req.params;
    const { user_id } = req.body;

    const existing = await db.prepare('SELECT id FROM likes WHERE post_id = ? AND user_id = ?').get(postId, user_id);

    if (existing) {
      await db.prepare('DELETE FROM likes WHERE id = ?').run(existing.id);
      res.json({ liked: false });
    } else {
      await db.prepare('INSERT INTO likes (id, post_id, user_id) VALUES (?, ?, ?)').run(uuidv4(), postId, user_id);
      
      // Create notification
      const post = await db.prepare('SELECT user_id FROM posts WHERE id = ?').get(postId);
      if (post) {
        createNotification(post.user_id, 'like', user_id, postId);
      }
      
      res.json({ liked: true });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/posts/:postId/liked/:userId', async (req, res) => {
  try {
    const like = await db.prepare('SELECT id FROM likes WHERE post_id = ? AND user_id = ?').get(req.params.postId, req.params.userId);
    res.json({ liked: !!like });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Comments
app.get('/api/posts/:postId/comments', async (req, res) => {
  try {
    const comments = await db.prepare(`
      SELECT c.*, u.full_name, u.role, u.class_grade, u.class_letter
      FROM comments c
      JOIN users u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `).all(req.params.postId);
    res.json(comments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/posts/:postId/comments', async (req, res) => {
  try {
    const { user_id, content } = req.body;
    const id = uuidv4();
    const created_at = new Date().toISOString();
    
    await db.prepare('INSERT INTO comments (id, post_id, user_id, content, created_at) VALUES (?, ?, ?, ?, ?)').run(id, req.params.postId, user_id, content, created_at);

    // Notify post owner
    const post = await db.prepare('SELECT user_id FROM posts WHERE id = ?').get(req.params.postId);
    if (post) {
      createNotification(post.user_id, 'comment', user_id, req.params.postId, id);
    }
    
    // Parse mentions and notify
    const mentions = parseMentions(content);
    for (const username of mentions) {
      const mentionedUser = await db.prepare('SELECT id FROM users WHERE username = ?').get(username);
      if (mentionedUser && mentionedUser.id !== user_id) {
        await createNotification(mentionedUser.id, 'mention', user_id, req.params.postId);
      }
    }


    const comment = await db.prepare(`
      SELECT c.*, u.full_name, u.role, u.class_grade, u.class_letter, u.profile_picture
      FROM comments c
      JOIN users u ON c.user_id = u.id
      WHERE c.id = ?
    `).get(id);

    res.status(201).json(comment);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/comments/:id', async (req, res) => {
  try {
    const { user_id } = req.body;
    const comment = await db.prepare('SELECT * FROM comments WHERE id = ?').get(req.params.id);
    
    if (!comment) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(user_id);

    if (comment.user_id !== user_id && user.role !== 'admin') {
      return res.status(403).json({ error: 'Not authorized' });
    }

    await db.prepare('DELETE FROM comments WHERE id = ?').run(req.params.id);
    res.json({ message: 'Comment deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Calendar
app.get('/api/calendar', async (req, res) => {
  try {
    const { userId } = req.query;
    const user = await db.prepare('SELECT * FROM users WHERE id = ?').get(userId);

    let events;
    if (user && user.role === 'student') {
      events = await db.prepare(`
        SELECT e.*, u.full_name as created_by_name
        FROM calendar_events e
        JOIN users u ON e.created_by = u.id
        WHERE 
          (e.class_grade IS NULL) OR
          (e.class_grade = ? AND e.class_letter = ?)
        ORDER BY e.event_date ASC
      `).all(user.class_grade, user.class_letter);
    } else {
      events = await db.prepare(`
        SELECT e.*, u.full_name as created_by_name
        FROM calendar_events e
        JOIN users u ON e.created_by = u.id
        ORDER BY e.event_date ASC
      `).all();
    }

    res.json(events);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/calendar/:id', async (req, res) => {
  try {
    const event = await db.prepare(`
      SELECT e.*, u.full_name as created_by_name
      FROM calendar_events e
      JOIN users u ON e.created_by = u.id
      WHERE e.id = ?
    `).get(req.params.id);
    
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }

    res.json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/calendar/:id', async (req, res) => {
  try {
    const { user_id } = req.body || {};
    if (!user_id) return res.status(400).json({ error: 'user_id is required' });

    const user = await db.prepare('SELECT id, role FROM users WHERE id = ?').get(user_id);
    if (!user) return res.status(404).json({ error: 'User not found' });

    const event = await db.prepare('SELECT id, created_by FROM calendar_events WHERE id = ?').get(req.params.id);
    if (!event) return res.status(404).json({ error: 'Event not found' });

    const isAdmin = user.role === 'admin';
    const isCreator = event.created_by === user.id;

    if (!isAdmin && !isCreator) {
      return res.status(403).json({ error: 'Not authorized to delete this event' });
    }

    await db.prepare('DELETE FROM calendar_events WHERE id = ?').run(req.params.id);
    res.json({ ok: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/calendar', async (req, res) => {
  try {
    const { title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by } = req.body;
    const id = uuidv4();
    
    await db.prepare(`
      INSERT INTO calendar_events (id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(id, title, description, location, event_date, event_time, event_type, class_grade, class_letter, created_by);

    const event = await db.prepare('SELECT * FROM calendar_events WHERE id = ?').get(id);
    res.status(201).json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Clubs
app.get('/api/clubs', async (req, res) => {
  try {
    const clubs = await db.prepare(`
      SELECT c.*, u.full_name as leader_name,
        (SELECT COUNT(*) FROM club_members WHERE club_id = c.id) as member_count
      FROM clubs c
      JOIN users u ON c.leader_id = u.id
      WHERE c.status = 'approved'
      ORDER BY c.name
    `).all();
    res.json(clubs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/clubs/:id', async (req, res) => {
  try {
    const club = await db.prepare(`
      SELECT c.*, u.full_name as leader_name,
        (SELECT COUNT(*) FROM club_members WHERE club_id = c.id) as member_count
      FROM clubs c
      JOIN users u ON c.leader_id = u.id
      WHERE c.id = ?
    `).get(req.params.id);

    if (!club) {
      return res.status(404).json({ error: 'Club not found' });
    }

    const members = await db.prepare(`
      SELECT u.id, u.full_name, u.role, u.class_grade, u.class_letter, cm.role as member_role
      FROM club_members cm
      JOIN users u ON cm.user_id = u.id
      WHERE cm.club_id = ?
      ORDER BY cm.role DESC, u.full_name
    `).all(req.params.id);

    club.members = members;
    res.json(club);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/clubs/:clubId', async (req, res) => {
  try {
    const { user_id } = req.body || {};
    if (!user_id) return res.status(400).json({ error: 'user_id is required' });

    const user = await db.prepare('SELECT id, role FROM users WHERE id = ?').get(user_id);
    if (!user) return res.status(404).json({ error: 'User not found' });

    const club = await db.prepare('SELECT id, leader_id FROM clubs WHERE id = ?').get(req.params.clubId);
    if (!club) return res.status(404).json({ error: 'Club not found' });

    const isAdmin = user.role === 'admin';
    const isLeader = club.leader_id === user.id;

    if (!isAdmin && !isLeader) {
      return res.status(403).json({ error: 'Not authorized to delete this club' });
    }

    await db.prepare('DELETE FROM club_members WHERE club_id = ?').run(club.id);
    await db.prepare('DELETE FROM clubs WHERE id = ?').run(club.id);

    res.json({ ok: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/clubs/:clubId/is-member/:userId', async (req, res) => {
  try {
    const member = await db.prepare('SELECT * FROM club_members WHERE club_id = ? AND user_id = ?').get(req.params.clubId, req.params.userId);
    res.json({ isMember: !!member });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/clubs', async (req, res) => {
  try {
    const { name, description, meeting_schedule, meeting_location, leader_id } = req.body;
    const id = uuidv4();
    
    await db.prepare('INSERT INTO clubs (id, name, description, meeting_schedule, meeting_location, leader_id) VALUES (?, ?, ?, ?, ?, ?)').run(id, name, description, meeting_schedule, meeting_location, leader_id);

    await db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)').run(uuidv4(), id, leader_id, 'leader');

    const club = await db.prepare('SELECT * FROM clubs WHERE id = ?').get(id);
    res.status(201).json(club);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/clubs/:clubId/join', async (req, res) => {
  try {
    const { user_id } = req.body;
    const existing = await db.prepare('SELECT * FROM club_members WHERE club_id = ? AND user_id = ?').get(req.params.clubId, user_id);

    if (existing) {
      return res.status(400).json({ error: 'Already a member' });
    }

    await db.prepare('INSERT INTO club_members (id, club_id, user_id, role) VALUES (?, ?, ?, ?)').run(uuidv4(), req.params.clubId, user_id, 'member');

    res.json({ message: 'Joined club' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/clubs/:clubId/leave', async (req, res) => {
  try {
    const { user_id } = req.body;
    
    await db.prepare('DELETE FROM club_members WHERE club_id = ? AND user_id = ?').run(req.params.clubId, user_id);

    res.json({ message: 'Left club' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Messages
app.get('/api/messages/conversations/:userId', async (req, res) => {
  try {
    const conversations = await db.prepare(`
      SELECT DISTINCT c.*,
        (SELECT content FROM messages WHERE conversation_id = c.id ORDER BY created_at DESC LIMIT 1) as last_message
      FROM conversations c
      JOIN conversation_participants cp ON c.id = cp.conversation_id
      WHERE cp.user_id = ?
      ORDER BY c.created_at DESC
    `).all(req.params.userId);

    for (const conv of conversations) {
      if (!conv.is_group) {
        const other = await db.prepare(`
          SELECT u.full_name
          FROM conversation_participants cp
          JOIN users u ON cp.user_id = u.id
          WHERE cp.conversation_id = ? AND cp.user_id != ?
        `).get(conv.id, req.params.userId);

        conv.name = other ? other.full_name : '–†–∞–∑–≥–æ–≤–æ—Ä';
      }
    }

    res.json(conversations);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/messages/:conversationId', async (req, res) => {
  try {
    const messages = await db.prepare(`
      SELECT m.*, u.full_name as sender_name
      FROM messages m
      JOIN users u ON m.sender_id = u.id
      WHERE m.conversation_id = ?
      ORDER BY m.created_at ASC
    `).all(req.params.conversationId);

    res.json(messages);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/messages/conversations', async (req, res) => {
  try {
    const { participants, is_group, name, created_by } = req.body;
    const convId = uuidv4();
    
    await db.prepare('INSERT INTO conversations (id, name, is_group, created_by) VALUES (?, ?, ?, ?)').run(convId, name || null, !!is_group, created_by || null);

    for (const userId of participants) {
      await db.prepare('INSERT INTO conversation_participants (id, conversation_id, user_id) VALUES (?, ?, ?)').run(uuidv4(), convId, userId);
    }

    const conversation = await db.prepare('SELECT * FROM conversations WHERE id = ?').get(convId);
    res.status(201).json(conversation);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/messages', async (req, res) => {
  try {
    const { sender_id, conversation_id, content } = req.body;
    const id = uuidv4();
    
    await db.prepare('INSERT INTO messages (id, sender_id, conversation_id, content) VALUES (?, ?, ?, ?)').run(id, sender_id, conversation_id, content);

    const message = await db.prepare('SELECT * FROM messages WHERE id = ?').get(id);
    res.status(201).json(message);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// NOTIFICATIONS
app.get('/api/notifications/:userId', async (req, res) => {
  try {
    const notifications = await db.prepare(`
      SELECT 
        n.*,
        u.full_name as actor_name,
        u.username as actor_username,
        u.profile_picture as actor_picture,
        p.content as post_content
      FROM notifications n
      JOIN users u ON n.actor_id = u.id
      LEFT JOIN posts p ON n.post_id = p.id
      WHERE n.user_id = ?
      ORDER BY n.created_at DESC
      LIMIT 50
    `).all(req.params.userId);
    
    res.json(notifications);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/notifications/:userId/unread-count', async (req, res) => {
  try {
    const result = await db.prepare('SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND is_read = 0').get(req.params.userId);
    res.json({ count: result.count });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/notifications/:notificationId/read', async (req, res) => {
  try {
    await db.prepare('UPDATE notifications SET is_read = 1 WHERE id = ?').run(req.params.notificationId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/notifications/:userId/read-all', async (req, res) => {
  try {
    await db.prepare('UPDATE notifications SET is_read = 1 WHERE user_id = ?').run(req.params.userId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ATTACHMENTS
app.get('/api/posts/:postId/attachments', async (req, res) => {
  try {
    const attachments = await db.prepare('SELECT * FROM post_attachments WHERE post_id = ? ORDER BY created_at ASC').all(req.params.postId);
    res.json(attachments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// MENTION SEARCH
app.get('/api/users/mention-search/:query', async (req, res) => {
  try {
    const query = `${req.params.query}%`;
    const users = await db.prepare(`
      SELECT id, username, full_name, profile_picture, role, class_grade, class_letter
      FROM users 
      WHERE username LIKE ? OR full_name LIKE ?
      ORDER BY username ASC
      LIMIT 10
    `).all(query, query);
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/health', async (req, res) => {
  res.json({ status: 'OK', message: 'School Social Network API' });
});

async function seedSimpleBulgarianPosts() {
  const users = await db.prepare('SELECT id FROM users').all();
  if (!users || users.length === 0) {
    console.log('No users found. Cannot seed posts.');
    return;
  }

  const postsText = [
    '–ù—è–∫–æ–π –∑–Ω–∞–µ –ª–∏ –∫–æ–≥–∞ —â–µ –Ω–∏ –≤—ä—Ä–Ω–∞—Ç –∫–æ–Ω—Ç—Ä–æ–ª–Ω–∏—Ç–µ –ø–æ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞?',
    '–£—Ç—Ä–µ –∏–º–∞–º–µ –∫–ª–∞—Å–Ω–æ –ø–æ –±—ä–ª–≥–∞—Ä—Å–∫–∏, —É—Å–ø–µ—Ö –Ω–∞ –≤—Å–∏—á–∫–∏!',
    '–ö–æ–π —â–µ —É—á–∞—Å—Ç–≤–∞ –≤ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏–µ—Ç–æ –ø–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞ —Ç–∞–∑–∏ –≥–æ–¥–∏–Ω–∞?',
    '–ù–∞–ø–æ–º–Ω—è–Ω–µ: —Å—Ä–æ–∫—ä—Ç –∑–∞ –ø—Ä–æ–µ–∫—Ç–∞ –ø–æ –∏—Å—Ç–æ—Ä–∏—è –µ –¥–æ –ø–µ—Ç—ä–∫.',
    '–ò–º–∞ –ª–∏ —Å–≤–æ–±–æ–¥–Ω–∏ –º–µ—Å—Ç–∞ –≤ –∫–ª—É–±–∞ –ø–æ —Ä–æ–±–æ—Ç–∏–∫–∞?',
    '–î–Ω–µ—Å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ç–∞ –ø–æ –≤–æ–ª–µ–π–±–æ–ª –µ –æ—Ç 16:30 –≤ —Å–∞–ª–æ–Ω–∞.',
    '–ú–æ–ª—è, —Å–ø–æ–¥–µ–ª–µ—Ç–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—è —É—Ä–æ–∫ –ø–æ —Ñ–∏–∑–∏–∫–∞.',
    '–ü—Ä–µ–¥—Å—Ç–æ–∏ —É—á–∏–ª–∏—â–Ω–∏—è—Ç –±–∞–ª ‚Äì –∫–æ–π –≤–µ—á–µ —Å–∏ –µ –∏–∑–±—Ä–∞–ª —Ç–æ–∞–ª–µ—Ç?',
    '–ß–µ—Å—Ç–∏—Ç –ø—Ä–∞–∑–Ω–∏–∫ –Ω–∞ –≤—Å–∏—á–∫–∏ —É—á–µ–Ω–∏—Ü–∏ –∏ —É—á–∏—Ç–µ–ª–∏!',
    '–ö–æ–π —â–µ —Ö–æ–¥–∏ –Ω–∞ –µ–∫—Å–∫—É—Ä–∑–∏—è—Ç–∞ –¥–æ –ü–ª–æ–≤–¥–∏–≤ —Ç–æ–∑–∏ –º–µ—Å–µ—Ü?',
    '–ù—è–∫–æ–π –∏–º–∞ –ª–∏ –∑–∞–ø–∏—Å–∫–∏—Ç–µ –ø–æ —Ö–∏–º–∏—è?',
    '–°—É–ø–µ—Ä –∏–Ω—Ç–µ—Ä–µ—Å–µ–Ω —É—Ä–æ–∫ –¥–Ω–µ—Å!',
    '–ö–æ–≥–∞ —â–µ –∫–∞—á–∞—Ç –æ—Ü–µ–Ω–∫–∏—Ç–µ?',
    '–ù—è–∫–æ–π –¥–∞ –ø–æ–º–æ–≥–Ω–µ —Å—ä—Å –∑–∞–¥–∞—á–∞ 5?',
    '–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –ø–æ –±–∞—Å–∫–µ—Ç–±–æ–ª —Å–ª–µ–¥ —á–∞—Å–æ–≤–µ—Ç–µ üèÄ'
  ];

  const visibilityOptions = ['public', 'class', 'grade'];

  const insert = db.prepare(`
    INSERT INTO posts (id, user_id, content, visibility, engagement_score, created_at)
    VALUES (?, ?, ?, ?, 0, ?)
  `);

  const TOTAL_POSTS = 400; // change if you want more

  for (let i = 0; i < TOTAL_POSTS; i++) {
    const randomUser = users[Math.floor(Math.random() * users.length)];
    const randomContent = postsText[Math.floor(Math.random() * postsText.length)];
    const randomVisibility = visibilityOptions[Math.floor(Math.random() * visibilityOptions.length)];

    // Random timestamp within last 30 days
    const daysAgo = Math.floor(Math.random() * 30);
    const hoursAgo = Math.floor(Math.random() * 24);
    const minutesAgo = Math.floor(Math.random() * 60);

    const createdAt = new Date(
      Date.now() - (
        daysAgo * 24 * 60 * 60 * 1000 +
        hoursAgo * 60 * 60 * 1000 +
        minutesAgo * 60 * 1000
      )
    );

    insert.run(
      uuidv4(),
      randomUser.id,
      randomContent,
      randomVisibility,
      createdAt.toISOString()
    );
  }

  console.log(`‚úì Seeded ${TOTAL_POSTS} Bulgarian posts with randomized timestamps`);
}


// Start server
(async () => {
  try {
await initDB();

// If Postgres is empty, bootstrap it either by migrating the bundled SQLite DB
// (same initial state as the SQLite version) or by running the built-in seed.
const countRow = await db.prepare('SELECT COUNT(*)::int AS count FROM users').get();
if ((countRow?.count || 0) === 0) {
  const auto = (process.env.AUTO_MIGRATE_SQLITE || 'true').toLowerCase() !== 'false';
  const sqlitePath = process.env.SQLITE_PATH || path.join(__dirname, 'sqlite_backup', 'school.db');
  if (auto && fs.existsSync(sqlitePath)) {
    console.log('No users found in Postgres. Migrating from SQLite:', sqlitePath);
    await migrateSqliteToPostgres({ sqlitePath, pg: db });
    console.log('‚úì SQLite ‚Üí Postgres migration finished');
  } else {
    const shouldSeed = (process.env.SEED_ON_EMPTY || 'false').toLowerCase() === 'true';

  if (!shouldSeed) {
    console.log('No users found in Postgres. Seeding is disabled (set SEED_ON_EMPTY=true to seed).');
  } else {
    console.log('No users found in Postgres. Seeding sample data...');
    await seedData();
    console.log('‚úì Seed finished');
  }
}
}

if ((process.env.SEED_SIMPLE_POSTS || 'false').toLowerCase() === 'true') {
      await seedSimpleBulgarianPosts();
    }


  } catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
})();
